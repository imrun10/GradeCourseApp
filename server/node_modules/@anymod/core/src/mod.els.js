import alias from "./alias.js";
import { addStyleString, removeStyleTag } from "./mod.style.js";
import { cloakEl } from "./mod.cloak.js";
import utils from "./utils.js";

const querySelectorString = () =>
  `[id^="${alias.lowerCase}-"],[data-${alias.lowerCase}]`;

/**
 * Find and return all mod tags on a page
 */
const findAllModEls = () => {
  try {
    document;
  } catch (error) {
    return [];
  }
  return [].slice.call(document.querySelectorAll(querySelectorString()));
};

/**
 * Determine the mod key for a given HTML element
 * @param {Element} el
 */
const getKeyFromEl = (el) => el.getAttribute("data-key") || "blank";

/**
 * Adds `data-key` attr to an element if `key=xxxxx` or `id="anymod-xxxxx"` attrs are defined
 *
 * @param {Element} el
 */
const addDataKeyToEl = (el) => {
  if (el.getAttribute("data-key")) return;
  if (el.getAttribute("key")) {
    return el.setAttribute("data-key", el.getAttribute("key"));
  }
  // If the id is anymod-xxxxx and not anymod-xxxxx-xxxxx, set the attribute
  if (el.id && el.id.indexOf(`${alias.lowerCase}-`) === 0) {
    const regex = new RegExp(`${alias.lowerCase}-`);
    const key = el.id.replace(regex, "");
    if (key.indexOf("-") < 0) {
      return el.setAttribute("data-key", key);
    }
  }
  el.setAttribute("data-key", "undefined");
};

/**
 * Add `data-key` attr to an element
 *
 * @param {Element} el
 */
function prepare(el) {
  if (!el) return;
  cloakEl(el);
  addDataKeyToEl(el);
}

/**
 * Run `prepare(el)` for all mod tags on a page
 *
 * @param {Object} opts
 */
const prepareAll = (opts) => {
  let els = findAllModEls(opts);
  els.map((el) => {
    prepare(el);
  });
  return els;
};

/**
 * Removes duplicate class names from an element
 *
 * @param {Element} el
 */
const removeClassNameDuplicates = (el) => {
  if (!el || !el.className) return;
  let classNames = el.className.split(" "),
    uniqueNames = [];
  classNames.map((name) => {
    if (name && uniqueNames.indexOf(name) < 0) uniqueNames.push(name);
  });
  el.className = uniqueNames.join(" ");
};

/**
 * Return boolean for whether el has content other than whitespace
 * @param {Element} el
 */
const elIsNotEmpty = (el) => {
  if (!el) return false;
  if (el.innerHTML.length > 20) return true;
  return (
    el.innerHTML &&
    el.innerHTML.trim &&
    el.innerHTML.trim().replace(/&nbsp;/i, "").length > 0
  );
};

/**
 * Add a newNode where an oldNode is in the DOM, and remove the oldNode
 *
 * @param {Element} newNode - element being added
 * @param {Element} oldNode - element being removed
 * @param {Boolean} ignoreOldNodeInnerHtml
 */
const replaceNode = (newNode, oldNode, opts) => {
  let parent = oldNode.parentNode;
  opts = opts || {};
  if (!parent) return console.warn("No parent for node", oldNode.outerHTML);
  if (oldNode.className) {
    newNode.className = newNode.className
      ? newNode.className + " " + oldNode.className
      : oldNode.className;
    removeClassNameDuplicates(newNode);
  }
  if (oldNode.id) newNode.id = oldNode.id;
  if (oldNode.style && oldNode.style.cssText)
    newNode.style.cssText = oldNode.style.cssText;
  if (elIsNotEmpty(oldNode) && !opts.ignoreOldNodeInnerHtml)
    newNode.innerHTML = oldNode.innerHTML;
  parent.insertBefore(newNode, oldNode.nextSibling);
  parent.removeChild(oldNode);
  return newNode;
};

/**
 * Insert a mod's CSS & cloaked HTML based on a placeholder element
 *
 * @param {Element} el - placeholder HTML tag where mod HTML should be added
 * @param {Object} mod - mod to be added
 * @param {String} instanceId - instance-specific ID generated on client (e.g. 'ranno-4u1supc')
 */
function insertModHtmlAndCss(el, mod, instanceId) {
  if (!el || !mod || !mod.key)
    return console.warn("Problem mounting mod ", el, mod);

  // Choose version of html, css, and data to use for operation
  const versionName = utils.currentVersionName();
  const { html, css, data } = utils.getCurrentModVersion(mod);

  // Add mod styling to DOM (remove any existing styling first)
  utils.debugLog([`[${mod.key}] Insert CSS`]);
  removeStyleTag(mod.key, "live");
  addStyleString(css, mod.key, "live", versionName);

  // Set up new parent
  let temporaryParent = document.createElement("div");

  // Use innerHTML if present
  if (elIsNotEmpty(el)) {
    let temporaryChild = document.createElement("div");
    temporaryChild.innerHTML = el.innerHTML;
    temporaryParent.appendChild(temporaryChild);
  } else {
    temporaryParent.innerHTML = html || "";
  }

  // Attach attributes
  let attrsToTransfer = [].slice.call(el.attributes);
  let attrsToSkip = ["data-key"];
  try {
    window.temporaryParent = temporaryParent;
    for (let i = 0; i < attrsToTransfer.length; i++) {
      let attrName = attrsToTransfer[i].nodeName;
      if (
        attrName.substring(0, 5) === "data-" &&
        attrsToSkip.indexOf(attrName) < 0
      )
        temporaryParent.firstElementChild.setAttribute(
          attrName,
          el.getAttribute(attrName)
        );
    }
  } catch (err) {
    console.warn(err);
  }
  temporaryParent.firstChild.id = `${alias.lowerCase}-${mod.key}`;
  cloakEl(temporaryParent.firstChild);
  temporaryParent.firstChild.setAttribute(
    `data-${alias.lowerCase}`,
    instanceId
  );
  temporaryParent.firstChild.setAttribute(mod.key, "");
  temporaryParent.firstChild.setAttribute(
    `data-${alias.lowerCase}-mounted`,
    ""
  );
  addNamespaceClasses(temporaryParent.firstChild, mod);
  utils.debugLog([`[${mod.key}] Insert HTML`]);
  return replaceNode(temporaryParent.firstChild, el);
}

/**
 * Add namespaces to an element if it uses namespaced CSS
 * e.g. `class="c19"`, `class="a01"`, etc
 *
 * @param {Element} el - element to operate on
 * @param {Object} mod - mod data object, which includes cssAssets
 */
const addNamespaceClasses = (el, mod) => {
  if (!mod || !mod.cssAssets || mod.cssAssets.length < 1) return;
  mod.cssAssets.map((asset) => {
    if (asset.indexOf("anymod.c19") > -1) el.className += " c19";
    if (asset.indexOf("anymod.c24") > -1) el.className += " c24";
    if (asset.indexOf("anymod.namespaced.") > -1) {
      el.className += " " + asset.split("anymod.namespaced.")[1].split(".")[0];
    }
  });
};

export {
  querySelectorString,
  replaceNode,
  getKeyFromEl,
  addDataKeyToEl,
  prepareAll,
  insertModHtmlAndCss,
  addNamespaceClasses,
};
