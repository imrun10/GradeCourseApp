import Singleton from "../src/singleton.js";
import alias from "./alias.js";
const utils = {};

utils.scriptTag = () => {
  try {
    document;
  } catch (error) {
    return;
  }
  return document.getElementById(`${alias.name}-script`);
};
utils.styleTag = () => {
  try {
    document;
  } catch (error) {
    return;
  }
  return document.querySelector(`[${alias.lowerCase}-styles]`);
};

const isArray = (obj) => {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

const executeCallback = (cb, arg) => {
  if (cb && typeof cb === "function") cb(arg);
};

/**
 * Generate an instanceId based on an eid
 * @param {String} eid
 */
utils.createInstanceId = (eid, joiner) => {
  joiner = joiner || "-";
  return `${eid}${joiner}${Math.random().toString(36).substr(2, 7)}`;
};

/**
 * Log a message if in debug mode
 * @param {Array} messages - Array of arguments to console.log
 */
utils.debugLog = (messages) => {
  if (!Singleton || !Singleton.Opts || !Singleton.Opts.debug) return;
  if (typeof messages === "string") messages = [messages];
  console.log.apply(null, [`[${alias.name}]`].concat(messages));
};

/**
 * Get array of mods to be mounted, with data from modsObj
 * @param {Array} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Object} modsObj - Mods object with data
 */
const getModsToMount = (tracking, modsObj) => {
  const modsArray = [];
  tracking.modsWithoutRemainingAssets.map((key) => {
    if (tracking.modsMounted.indexOf(key) > -1) return;
    if (key && modsObj[key]) modsArray.push(modsObj[key]);
  });
  return modsArray;
};

/**
 * Return array of mod keys in the order they appear in the document
 */
const getModKeysInDocumentOrder = () => {
  const modEls = [].slice.call(
    document.querySelectorAll(
      `[id^="${alias.lowerCase}-"],[data-${alias.lowerCase}]`
    )
  );
  const modKeys = [];
  modEls.map((el) => {
    if (el && el.id && el.id !== `${alias.lowerCase}-blank`) {
      const re = new RegExp(`(${alias.lowerCase}-)`, "g");
      const key = el.id.replace(re, "");
      if (modKeys.indexOf(key) < 0) modKeys.push(key);
    }
  });
  return modKeys;
};

/**
 * Returns first n keys found on the page
 * @param {Number} n
 */
const getFirstNKeysFromPage = (n) => {
  const keysInOrder = getModKeysInDocumentOrder();
  const keysToReturn = [];
  for (let i = 0; i < keysInOrder.length; i++) {
    if (keysToReturn.length >= n) return keysToReturn;
    if (keysToReturn.indexOf(keysInOrder[i]) < 0)
      keysToReturn.push(keysInOrder[i]);
  }
  return keysToReturn;
};

/**
 * Returns priority key array based on Singleton.Opts.priority (array or number)
 */
const getPriorityKeys = () => {
  if (!Singleton || !Singleton.Opts) {
    return getFirstNKeysFromPage(3);
  } else if (isArray(Singleton.Opts.priority)) {
    return Singleton.Opts.priority;
  } else {
    const n =
      typeof Singleton.Opts.priority === "number"
        ? Math.max(parseInt(Singleton.Opts.priority), 0)
        : 3;
    return getFirstNKeysFromPage(n);
  }
};

/**
 * Scans the DOM for mods and returns the first 3 uniques (top to bottom)
 * @param {Object} mods - Object with mod data
 */
const getPriorityMods = (mods) => {
  const priorityKeys = getPriorityKeys();
  const priorityMods = {};
  priorityKeys.map((key) => {
    if (key && mods[key]) priorityMods[key] = mods[key];
  });
  return priorityMods;
};

/**
 * Returns mods from allMods that are not in priorityMods
 * @param {Object} priorityMods
 * @param {Object} allMods
 */
const getNonPriorityMods = (priorityMods, allMods) => {
  const nonPriorityMods = {};
  Object.keys(allMods).map((key) => {
    if (!priorityMods[key]) nonPriorityMods[key] = allMods[key];
  });
  return nonPriorityMods;
};

/**
 * Given a mod object, returns an object with jsAssets & cssAssets arrays
 * @param {Object} mods
 */
const getModAssets = (mods) => {
  let jsAssets = [],
    cssAssets = [];
  Object.keys(mods).map((key) => {
    jsAssets = jsAssets.concat(mods[key].jsAssets || []);
    cssAssets = cssAssets.concat(mods[key].cssAssets || []);
  });
  return { jsAssets, cssAssets };
};

/**
 * Remove a url from the tracking.queuedAssets array
 * @param {Object} tracking
 * @param {String} url
 */
const removeFromQueuedAssets = (tracking, url) => {
  if (!tracking || !url) return;
  tracking.queuedAssets = tracking.queuedAssets.filter((u) => u !== url);
};

/**
 * Add a script tag to the DOM and run a callback on load
 * @param {String} url
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Function} cb
 * @param {Element} tag - HTML element to insert script tag before
 */
const loadScript = (url, tracking, cb, tag) => {
  if (tracking.queuedAssets.indexOf(url) > -1) return;
  if (!!document.querySelector('script[src="' + url + '"]')) {
    tracking.assetsOnPage.push(url);
    return executeCallback(cb);
  }
  tracking.queuedAssets.push(url);
  let js = document.createElement("script");
  js.onload = () => {
    utils.debugLog(["Loaded", url]);
    tracking.jsAssetsLoaded.push(url);
    removeFromQueuedAssets(tracking, url);
    executeCallback(cb);
  };
  js.onerror = () => {
    utils.debugLog(["Error Loading", url]);
    tracking.jsAssetsLoaded.push(url);
    removeFromQueuedAssets(tracking, url);
    executeCallback(cb);
  };
  if (tag) {
    tag.parentNode.insertBefore(js, tag);
  } else {
    document.body && document.body.appendChild(js);
  }
  js.defer = true;
  js.async = false; // Force scripts to load in correct order
  js.src = url;
};

/**
 * Add a style tag to the DOM and run a callback on load
 *
 * @param {String} url
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Function} cb
 * @param {Element} tag - HTML element to insert script tag before
 */
const loadStyle = (url, tracking, cb, tag) => {
  if (tracking.queuedAssets.indexOf(url) > -1) return;
  if (!!document.head.querySelector('link[href="' + url + '"]')) {
    tracking.assetsOnPage.push(url);
    return executeCallback(cb);
  }
  tracking.queuedAssets.push(url);
  let css = document.createElement("link");
  css.onload = () => {
    utils.debugLog(["Loaded", url]);
    tracking.cssAssetsLoaded.push(url);
    removeFromQueuedAssets(tracking, url);
    executeCallback(cb);
  };
  css.onerror = () => {
    utils.debugLog(["Error Loading", url]);
    tracking.cssAssetsLoaded.push(url);
    removeFromQueuedAssets(tracking, url);
    executeCallback(cb);
  };
  css.rel = "stylesheet";
  css.href = url;
  tag = tag || utils.scriptTag() || utils.styleTag();
  if (!tag) return document.head.appendChild(css);
  tag.parentNode.insertBefore(css, tag);
};

/**
 * Load all JS assets for a given set of mods, calling cb when finished
 * @param {Array} jsAssets - JS assets to load
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Object} mods - Hash of mod data to load
 * @param {Function} modCb - Cb to call on each mod when it loads
 * @param {Function} overallCb - Cb to call when all mods have loaded
 * @param {Element} tag - DOM element to append script tags to
 */
const loadJsAssets = (jsAssets, tracking, mods, modCb, overallCb, tag) => {
  if (!jsAssets || jsAssets.length === 0) return;
  while (jsAssets.length > 0) {
    let url = jsAssets.shift();
    if (tracking.jsAssetsLoaded.indexOf(url) > -1) continue;
    loadScript(
      url,
      tracking,
      () => {
        removeAssetFromRemaining(url, tracking);
        setModsWithoutRemainingAssets(tracking);
        executeCbForMods(getModsToMount(tracking, mods), modCb);
        executeCbIfAllAssetsLoaded(tracking, overallCb);
      },
      tag
    );
  }
};

/**
 * Load all CSS assets for a given set of mods, calling cb when finished
 * @param {Array} cssAssets - CSS assets to load
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Object} mods - Hash of mod data to load
 * @param {Function} modCb - Cb to call on each mod when it loads
 * @param {Function} overallCb - Cb to call when all mods have loaded
 * @param {Element} tag - DOM element to append script tags to
 */
const loadCssAssets = (cssAssets, tracking, mods, modCb, overallCb, tag) => {
  if (!cssAssets || cssAssets.length === 0) return;
  while (cssAssets.length > 0) {
    let url = cssAssets.shift();
    if (tracking.cssAssetsLoaded.indexOf(url) > -1) continue;
    loadStyle(
      url,
      tracking,
      () => {
        removeAssetFromRemaining(url, tracking);
        setModsWithoutRemainingAssets(tracking);
        executeCbForMods(getModsToMount(tracking, mods), modCb);
        executeCbIfAllAssetsLoaded(tracking, overallCb);
      },
      tag
    );
  }
};

/**
 * Loop over all mods and add to either tracking.modsWithRemainingAssets
 * or tracking.modsWithoutRemainingAssets, depending on whether mod has assets to load
 *
 * @param {Object} mods - Hash of mod data for the page
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 */
const populateRemainingAssetArrays = (mods, tracking) => {
  Object.keys(mods).map((key) => {
    const jsAssets = mods[key].jsAssets,
      cssAssets = mods[key].cssAssets,
      jsAssetsToLoad = jsAssets.filter(
        (asset) => tracking.jsAssetsLoaded.indexOf(asset) < 0
      ),
      cssAssetsToLoad = cssAssets.filter(
        (asset) => tracking.cssAssetsLoaded.indexOf(asset) < 0
      );
    if (jsAssetsToLoad.length < 1 && cssAssetsToLoad.length < 1) {
      if (tracking.modsWithoutRemainingAssets.indexOf(key) < 0)
        tracking.modsWithoutRemainingAssets.push(key);
    } else {
      tracking.modsWithRemainingAssets.push({
        key,
        remainingAssets: jsAssetsToLoad.concat(cssAssetsToLoad),
      });
    }
  });
};

/**
 * Remove an asset from a mod in the modsWithRemainingAssets array
 *
 * @param {Object} mod - mod in modsWithRemainingAssets array
 * @param {String} url - asset to remove
 */
const removeAssetFromMod = (mod, url) => {
  if (!mod) return;
  mod.remainingAssets = mod.remainingAssets.filter((el) => el !== url);
};

/**
 * Remove an asset from all modsWithRemainingAssets
 *
 * @param {String} url - asset to remove
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 */
const removeAssetFromRemaining = (url, tracking) => {
  tracking.modsWithRemainingAssets.map((mod) => {
    removeAssetFromMod(mod, url);
  });
};

const removeAssetFromRemainingIfLoaded = (tracking) => {
  tracking.cssAssetsLoaded.map((url) =>
    removeAssetFromRemaining(url, tracking)
  );
  tracking.jsAssetsLoaded.map((url) => removeAssetFromRemaining(url, tracking));
};

/**
 * Check a modWithRemainingAssets to see if it's ready.
 * If it is ready, push its key onto modsWithoutRemainingAssets and remove it from modsWithRemainingAssets.
 * @param {Object} mod - A mod object from the modsWithRemainingAssets array
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 */
const setModRemainingAssets = (mod, tracking) => {
  if (!mod || !mod.remainingAssets || !tracking) return;
  if (mod.remainingAssets.length === 0) {
    if (tracking.modsWithoutRemainingAssets.indexOf(mod.key) < 0)
      tracking.modsWithoutRemainingAssets.push(mod.key);
    tracking.modsWithRemainingAssets = tracking.modsWithRemainingAssets.filter(
      (m) => m.key !== mod.key
    );
  }
};

/**
 * Loop over all modsWithRemainingAssets and check for readiness
 * If it is ready, push its key onto modsWithoutRemainingAssets and remove it from modsWithRemainingAssets.
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 */
const setModsWithoutRemainingAssets = (tracking) => {
  if (!tracking.modsWithRemainingAssets) return;
  tracking.modsWithRemainingAssets.map((mod) =>
    setModRemainingAssets(mod, tracking)
  );
};

/**
 * For any mods in array, execute the cb if present
 * @param {Object} mods - Hash of mod data for the page
 * @param {Object} keyArr - Array of mod keys
 * @param {Function} cb
 */
const executeCbForMods = (modsArr, cb) => {
  if (!modsArr) return;
  modsArr.map((mod) => executeCallback(cb, mod));
};

/**
 * Execute the provided callback if all assets have loaded
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Function} cb
 */
const executeCbIfAllAssetsLoaded = (tracking, cb) => {
  if (!tracking.modsWithRemainingAssets) return;
  if (tracking.modsWithRemainingAssets.length === 0) executeCallback(cb);
};

/**
 * Assign local tracking attributes to a parent scope
 * @param {Object} parent - Parent scope (Singleton.Page or AnyModPageJs)
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Boolean} priorityOnly - Whether the process is priority only
 */
const assignParentAttrs = (parent, tracking, priorityOnly) => {
  if (!parent || !tracking) return;
  parent.modsMounted = tracking.modsMounted;
  parent.cssAssetsLoaded = tracking.cssAssetsLoaded;
  parent.jsAssetsLoaded = tracking.jsAssetsLoaded;
  parent.assetsOnPage = tracking.assetsOnPage;
  parent.queuedAssets = tracking.queuedAssets;
  if (priorityOnly) {
    parent.cssAssetsToLog = tracking.cssAssetsLoaded;
    parent.jsAssetsToLog = tracking.jsAssetsLoaded;
  }
};

/**
 *
 * @param {Object} mods - Hash of mod data
 * @param {Object} tracking - Object with info to track what has been loaded, mounted, etc
 * @param {Function} modCb - Callback to call on mods as they become ready to mount
 * @param {Function} overallCb - Callback to call after all assets are loaded
 * @param {Object} opts - Options used for testing
 */
const loadMods = (mods, tracking, modCb, overallCb, opts) => {
  utils.debugLog([`Loading ${opts.priority ? "priority " : ""}mods`, mods]);
  opts = opts || {};

  if (!mods || Object.keys(mods).length === 0)
    return executeCallback(overallCb);

  // Loop over mods and add to modsWithRemainingAssets or modsWithoutRemainingAssets
  populateRemainingAssetArrays(mods, tracking);
  removeAssetFromRemainingIfLoaded(tracking);

  // Set mods / pages that don't have any assets as such
  setModsWithoutRemainingAssets(tracking);

  const assets = getModAssets(mods);
  utils.debugLog(["[JS]"].concat(assets.jsAssets));
  utils.debugLog(["[CSS]"].concat(assets.cssAssets));

  // Execute mod callbacks for mods without remaining assets
  executeCbForMods(getModsToMount(tracking, mods), modCb);

  // Execute overall callback if everything is done
  executeCbIfAllAssetsLoaded(tracking, overallCb);

  // Load all JS assets and check for readiness after each load
  const tagToAppendJsTo =
    (opts.priority && (opts.scriptTag || utils.scriptTag())) || undefined;
  loadJsAssets(
    assets.jsAssets,
    tracking,
    mods,
    modCb,
    overallCb,
    tagToAppendJsTo
  );

  // Load all CSS assets and check for readiness after each load
  loadCssAssets(
    assets.cssAssets,
    tracking,
    mods,
    modCb,
    overallCb,
    opts.styleTag
  );

  // Update parent scope
  assignParentAttrs(opts.parent, tracking, opts.priorityOnly);
};

/**
 * - Takes the cssAssets and jsAssets arrays and load them all
 * - Loops over all mods in mods hash and either adds to tracking.modsWithRemainingAssets
 *   or to tracking.modsWithoutRemainingAssets, depending on whether each mod has assets to load
 * - As each asset loads, checks tracking.modsWithRemainingAssets
 * - When a mod has no more remaining assets:
 *   - Add it to tracking.modsWithoutRemainingAssets
 *   - Remove it from tracking.modsWithRemainingAssets
 *   - Call the callback if provided (to mount mod: replace innerHTML, evaluate JS, and uncloak)
 * - When all assets are loaded, call the overall callback if provided
 *
 * @param {Object} mods - Hash of mod data for the page
 * @param {Function} modCb - Callback to call on mods as they become ready to mount
 * @param {Function} overallCb - Callback to call after all assets are loaded
 * @param {Object} opts - Options used for operation, scoping, and testing
 *                 opts.priorityOnly - Only load/mount priority mods
 *                 opts.parent - Reference to a parent scope (Singleton.Page or AnyModPageJs)
 *                 opts.tracking - Used for tracking which mods have been loaded/mounted
 *                 opts.async - loadPageAssets call is being made asynchronously
 */
utils.loadPageAssets = ({ mods }, opts) => {
  try {
    document;
  } catch (error) {
    return;
  }

  if (!mods) return;
  opts = opts || {};
  if (!opts.parent) opts.parent = (Singleton && Singleton.Page) || {};
  const overallCb = opts.overallCb;
  /**
   * Tracking mod load & mount progress
   */
  const tracking = {
    modsWithRemainingAssets: [],
    modsWithoutRemainingAssets: [],
    modsMounted: (!opts.async && opts.parent.modsMounted) || [],
    queuedAssets: opts.parent.queuedAssets || [],
    cssAssetsLoaded: opts.parent.cssAssetsLoaded || [],
    jsAssetsLoaded: opts.parent.jsAssetsLoaded || [],
    assetsOnPage: opts.parent.assetsOnPage || [],
    // iteration: Math.random().toString(36).substring(2,6).toUpperCase()
  };
  opts.parent.tracking = opts.parent.tracking || tracking;

  const priorityMods = getPriorityMods(mods);
  const nonPriorityMods = getNonPriorityMods(priorityMods, mods);

  const modCallback = (arg) => {
    executeCallback(opts.modCb, arg);
    if (opts.modCb && arg && arg.key) tracking.modsMounted.push(arg.key);
    assignParentAttrs(opts.parent, tracking, opts.priorityOnly);
  };

  const overallCallback = () => {
    assignParentAttrs(opts.parent, tracking, opts.priorityOnly);
    executeCallback(overallCb, tracking);
  };

  // Load priority mods first, then load others
  opts.priority = true;
  loadMods(
    priorityMods,
    tracking,
    modCallback,
    () => {
      if (opts.priorityOnly) {
        return executeCallback(overallCallback);
      }
      setTimeout(() => {
        opts.priority = false;
        loadMods(nonPriorityMods, tracking, modCallback, overallCallback, opts);
      }, 1);
    },
    opts
  );
};

utils.currentVersionName = () =>
  (Singleton.Version && Singleton.Version.currentVersion) || "default";

/**
 * Return html, css, and data for the current version of a mod
 * @param {Object} mod
 * @return {Object} { html, css, data } for the current version
 */
utils.getCurrentModVersion = (mod) => {
  const versionName = utils.currentVersionName();
  if (!mod || !mod.versions || !mod.versions[versionName]) return mod || {};
  const version = {};
  mod.versions.default = mod.versions.default || {};
  version.data =
    mod.versions[versionName].data || mod.versions.default.data || mod.data;
  version.html = mod.versions[versionName].hasOwnProperty("html")
    ? mod.versions[versionName].html
    : mod.versions.default.html;
  version.css = mod.versions[versionName].hasOwnProperty("css")
    ? mod.versions[versionName].css
    : mod.versions.default.css;
  return version;
};

export default utils;
