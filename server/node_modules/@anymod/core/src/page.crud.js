import Singleton from "./singleton.js";
import crud from "./crud.js";
import { setUnmounted } from "./mod.mount.js";
import { getKeyFromEl } from "./mod.els.js";
import { addToCallbacks } from "./mod.ready.js";

/**
 * Add the Script 1 tag to the page, causing a GET request
 * for the JS file containing the page object. This functionality is
 * the same as what is contained in the on-page snippet.
 * @param {String} baseUrl - The URL base for the script tag's src
 * @param {String} identifier - The identifier of the project
 * @param {Function} callback - Optional callback to run after script is loaded
 */
const addScript1ToDocument = (baseUrl, identifier, callback) => {
  Singleton.initialize();

  // Add callbacks to the ready queue
  Singleton.rq = Singleton.rq || [];
  addToCallbacks(Singleton.rq);

  // Set up ready() method. Likely not used, but maintains 1:1 mapping
  Singleton.ready = function (x) {
    Singleton.rq.push(x);
  };

  // Exit if in SSR mode (document is not present)
  try {
    document;
  } catch (error) {
    return;
  }

  // Set up URLs
  baseUrl = baseUrl || "https://cdn.anymod.com/v2/page/";
  const encodedHost = encodeURIComponent(btoa(window.location.host));
  const encodedPathname = encodeURIComponent(btoa(window.location.pathname));
  const srcUrl = `${baseUrl}${identifier}/${encodedPathname}/${encodedHost}`;

  // If the script tag already exists, return
  const foundScript = document.querySelector(`script[src^='${baseUrl}']`);
  if (!!foundScript) return;

  // Create the script tag
  const scriptTag = document.createElement("script");
  scriptTag.defer = true;
  scriptTag.src = `${srcUrl}?t=${Date.now()}`;

  // Add a loading callback, with Singleton.isScript1Loading available for status
  Singleton.isScript1Loading = true;
  scriptTag.onload = () => {
    Singleton.isScript1Loading = false;
    if (callback && typeof callback === "function") callback();
  };

  // Insert before first script in the head. If no first script, append to head.
  const firstScriptInHead = document.head.getElementsByTagName("script")[0];
  if (firstScriptInHead) {
    firstScriptInHead.parentNode.insertBefore(scriptTag, firstScriptInHead);
  } else {
    document.getElementsByTagName("head")[0].appendChild(scriptTag);
  }
};

/**
 * Return the page if it has been defined; otherwise create a new one
 */
const createOrReturnPage = () => {
  // Initialize the Singleton, in case it has not been defined
  Singleton.initialize();

  // Check if the current page is window.AnyModPageJs
  Singleton.assignFromAnyModPageJsIfMatch();

  // Check if the current page is the one needed
  if (pageMatchesCurrentLocation(Singleton.Page.page)) {
    return Promise.resolve(Singleton.Page.page);
  }

  // Check if there are any matching prior pages
  for (let i = 0; i < Singleton.Page.priorPages.length; i++) {
    if (pageMatchesCurrentLocation(Singleton.Page.priorPages[i])) {
      return Promise.resolve(Singleton.Page.priorPages[i]);
    }
  }
  // If no matching pages, create one
  return createPage();
};

/**
 * Determine whether a page object is for the current URL
 * @param {Object} page
 */
function pageMatchesCurrentLocation(page) {
  return (
    page &&
    page.id &&
    page.host === window.location.host &&
    page.pathname === window.location.pathname
  );
}

/**
 * Create a page record by POSTing an array of explicit keys found on the page
 */
const createPage = async () => {
  if (Singleton.Opts.api === false) return Promise.resolve({});
  const explicitKeys = [];
  setUnmounted();
  Singleton.Page.unmountedEls.map((el) => {
    const key = getKeyFromEl(el);
    if (key && key !== "blank" && key !== "undefined") {
      explicitKeys.push(key);
    }
  });
  if (explicitKeys.length < 1) {
    Singleton.Page.page = { mods: {} };
    return Promise.resolve({});
  }
  const page = await crud.post(explicitKeys);
  Singleton.Page.page = page;
  addPageToPriorPages(page);
  return page;
};

/**
 * Add a page to the priorPages array (or update it)
 * @param {Object} page
 */
function addPageToPriorPages(page) {
  // Check for match and update if match
  for (let i = 0; i < Singleton.Page.priorPages.length; i++) {
    if (Singleton.Page.priorPages[i].id === page.id) {
      return (Singleton.Page.priorPages[i] = page);
    }
  }
  // Push if a match does not exist
  Singleton.Page.priorPages.push(page);
}

/**
 * Check the page for new mods that are not in the existing Singleton.Page.page.mods
 * object and that do not have an associated error message. In the event that there
 * are new mods, perform a PUT request to update the page.
 */
const checkPageAndUpdate = async (page) => {
  if (!page || !page.id || Singleton.Opts.api === false) {
    return Promise.resolve(page);
  }
  const explicitKeys = [];
  let hasNewExplicitKey = false;
  setUnmounted();
  Singleton.Page.unmountedEls.map((el) => {
    const key = getKeyFromEl(el);
    if (!key || key === "blank" || key === "undefined") return;
    if (!page.mods[key]) return explicitKeys.push(key);
  });
  explicitKeys.map((key) => {
    if (
      page.errorMessages &&
      page.errorMessages[key] == "Mod not found in project"
    ) {
      return;
    }
    hasNewExplicitKey = true;
  });
  // No new mods
  if (explicitKeys.length < 1 || !hasNewExplicitKey) {
    return Promise.resolve(page);
  }
  // New mods
  const updatedPage = await crud.put(page.id, explicitKeys);
  Singleton.Page.page = updatedPage;
  return updatedPage;
};

export { addScript1ToDocument, createOrReturnPage, checkPageAndUpdate };
