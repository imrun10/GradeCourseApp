{"version":3,"file":"userfront-react.modern.js","sources":["../src/index.js"],"sourcesContent":["import React, { memo } from \"react\";\nimport AnyMod from \"@anymod/core\";\nimport Core from \"@userfront/core\";\n\nconst {\n  Singleton,\n  alias,\n  render,\n  processPage,\n  addScript1ToDocument,\n  createOrReturnPage,\n  checkPageAndUpdate,\n  executeCallbacks,\n  logErrorsAndTips,\n} = AnyMod;\n\nconst { registerUrlChangedEventListener, addInitCallback } = Core;\nalias.setAlias(\"Userfront\");\n\nSingleton.Opts.api = true;\n\n/**\n * The order of operations is:\n *  1. Userfront.init() is called\n *  2. Callback is fired that adds Script1 to document and sets Singleton.isScript1Loading = true\n *  3. Userfront.build() is called\n *  4. componentDidMount() is called\n *  5. mountTools() is called\n *  6a. If Script1 hasn't loaded yet, wait for it to load\n *  6b. If Script1 has loaded, continue\n *  7. runAnyModSetup() is called\n */\n\n// Callback to fire whenever Userfront.init is called\naddInitCallback(({ tenantId }) => {\n  Singleton.External.project = tenantId;\n  addScript1ToDocument(\n    \"https://cdn.userfront.com/toolkit/page/\",\n    tenantId,\n    runAnyModSetup\n  );\n});\n\nregisterUrlChangedEventListener();\n\nif (typeof window === \"object\") {\n  window.addEventListener(\"urlchanged\", render);\n}\n\nasync function runAnyModSetup() {\n  if (Singleton.isScript1Loading) return;\n  const page = await createOrReturnPage();\n  const updatedPage = await checkPageAndUpdate(page);\n  await processPage(updatedPage);\n  executeCallbacks();\n  logErrorsAndTips();\n}\n\nasync function mountTools() {\n  try {\n    runAnyModSetup();\n  } catch (err) {\n    let message = err && err.message ? err.message : \"Problem loading page\";\n    console.warn(message, err);\n  }\n}\n\nconst Userfront = {\n  build({ toolId }) {\n    class Anon extends React.Component {\n      componentDidMount() {\n        mountTools();\n      }\n      render() {\n        return (\n          <div>\n            <div id={`userfront-${toolId}`}></div>\n          </div>\n        );\n      }\n    }\n    return memo(Anon);\n  },\n  /**\n   * This is the hook way to do it, which we're not\n   * using because it's not compatible with older\n   * versions of React.\n   */\n  // hook({ tenantId, toolId }) {\n  //   return function Anon() {\n  //     useEffect(() => {\n  //       mount();\n  //     });\n  //     return (\n  //       <div>\n  //         <div id={`userfront-${toolId}`}></div>\n  //       </div>\n  //     );\n  //   };\n  // },\n};\n\nfor (const attr in Core) {\n  if (!Userfront[attr]) Userfront[attr] = Core[attr];\n}\n\nexport default Userfront;\n"],"names":["Singleton","alias","render","processPage","addScript1ToDocument","createOrReturnPage","checkPageAndUpdate","executeCallbacks","logErrorsAndTips","AnyMod","registerUrlChangedEventListener","addInitCallback","Core","async","isScript1Loading","page","updatedPage","setAlias","Opts","api","tenantId","External","project","runAnyModSetup","window","addEventListener","build","toolId","Component","componentDidMount","err","console","warn","message","mountTools","React","id","memo","Anon","Userfront","attr"],"mappings":"2FAIA,MAAMA,UACJA,EADIC,MAEJA,EAFIC,OAGJA,EAHIC,YAIJA,EAJIC,qBAKJA,EALIC,mBAMJA,EANIC,mBAOJA,EAPIC,iBAQJA,EARIC,iBASJA,GACEC,GAEEC,gCAAEA,EAAFC,gBAAmCA,GAAoBC,EAiC7DC,mBACE,GAAIb,EAAUc,iBAAkB,OAChC,4BAC6CC,WAC3BC,GAClBT,IACAC,IAtCFP,EAAMgB,SAAS,aAEfjB,EAAUkB,KAAKC,KAAM,EAerBR,EAAgB,EAAGS,SAAAA,MACjBpB,EAAUqB,SAASC,QAAUF,EAC7BhB,EACE,0CACAgB,EACAG,KAIJb,IAEsB,yBACpBc,OAAOC,iBAAiB,aAAcvB,GAqBxC,QAAkB,CAChBwB,OAAMC,OAAEA,IACN,kBAAyBC,UACvBC,qBAZNhB,iBACE,IACEU,IACA,MAAOO,GAEPC,QAAQC,KADMF,GAAOA,EAAIG,QAAUH,EAAIG,QAAU,uBAC3BH,IAQlBI,GAEFhC,SACE,OACEiC,2BACEA,uBAAKC,GAAK,aAAYT,MAK9B,OAAOU,EAAKC,KAqBhB,IAAK,aACEC,EAAUC,KAAOD,EAAUC,GAAQ5B,EAAK4B"}